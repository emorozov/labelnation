From: "Kevin M. Myer" <kevin_myer@iu13.k12.pa.us>
Subject: Patch to add new functionality
To: bug-labelnation@red-bean.com
Date: Wed, 2 Aug 2000 13:49:03 -0400 (EDT)

Hello Karl,

I came across your labelnation code when I was trying to find something to
print out my wedding invitation labels.  It seemed to do the trick with a
few problems:  more then one page of labels wasn't supported and the
generated Postscript didn't have a header to identify itself as Postscript
- hence, it printed as plain ASCII text.

I have attached a diff against the latest labelnation 1.8 code that adds
the following functionality:

1)  Adds support to print out multiple pages of labels with autogeneration
of page numbers.  For example, if using a label type that has 30 labels
per page and you have 50 addresses, it will print two sheets, the first
with your first 30 addresses and the second with your last 20 and then
wrap around to your first 10.

2)  Adds some very basic header support to identify the output as a
Postscript document.
  *** kff: this is already done ***

NB:  This has not been tested very heavily.  I only tested it with a label
sheet that had 30 labels per page.  I got it working to the stage where it
got my wedding labels printed but I might clean it up more if I get the
change later on.

Kevin

-- 
Kevin M. Myer
Systems Administrator
Lancaster-Lebanon Intermediate Unit 13
(717)-560-6140

--------------------8-<-------cut-here---------8-<-----------------------

*** labelnation.pl	2000/08/13 20:53:24	1.9
--- labelnation.pl	2000/08/13 21:14:30
***************
*** 25,31 ****
  ### rectangles arranged regularly on a printer-ready sheet.
  
  use strict;
! 
  ################ Globals ###################
  
  my $Type              = "";      # A predefined label type
--- 25,31 ----
  ### rectangles arranged regularly on a printer-ready sheet.
  
  use strict;
! use POSIX;
  ################ Globals ###################
  
  my $Type              = "";      # A predefined label type
***************
*** 46,52 ****
  my $Font_Name         = "";      # Defaults to Times-Roman
  my $Font_Size         = "";      # Defaults to 12
  my $Outfile           = "";      # Defaults to labelnation.ps
! 
  # User-specified PostScript code, one string of code for each label.
  # Each element of the array is a string of PostScript code, and each
  # will be drawn once to a label, then it will cycle again from the
--- 46,54 ----
  my $Font_Name         = "";      # Defaults to Times-Roman
  my $Font_Size         = "";      # Defaults to 12
  my $Outfile           = "";      # Defaults to labelnation.ps
! my $Number_Per_Page   = -1;
! my $Label_Count       = -1;
! my $Pages_Of_Labels   = -1;
  # User-specified PostScript code, one string of code for each label.
  # Each element of the array is a string of PostScript code, and each
  # will be drawn once to a label, then it will cycle again from the
***************
*** 72,78 ****
  ############## End Globals #################
  
  
- 
  ### Code.
  
  &parse_options ();
--- 74,79 ----
***************
*** 80,86 ****
  &print_labels ();
  
  
- 
  ### Subroutines.
  
  sub maybe_make_label_codes ()
--- 81,86 ----
***************
*** 94,107 ****
      # Default to a label showing the empty string
      $Label_Lines[0][0] = "";
    }
  
    # Else we need to generate PostScript code
!   for (my $i = 0; $i < scalar (@Label_Lines); $i++)
    {
      my $reffy = $Label_Lines[$i];
      my @these_lines = @$reffy;
      my $num_lines = scalar (@these_lines);
-   
      # For now, we just handle 1 thru 4 lines the same, and punt the rest
      if ($num_lines > 5) {
        die "Oops, I can't handle more than 5 lines of label yet.  Sorry!";
--- 94,112 ----
      # Default to a label showing the empty string
      $Label_Lines[0][0] = "";
    }
+     # Create two variables to deal with number of pages and number of
+     # labels.  
+ 
+   $Label_Count = scalar(@Label_Lines);
+   $Pages_Of_Labels = ceil($Label_Count / $Number_Per_Page);
  
    # Else we need to generate PostScript code
!   for (my $i = 0; $i < $Label_Count; $i++)
    {
+ 
      my $reffy = $Label_Lines[$i];
      my @these_lines = @$reffy;
      my $num_lines = scalar (@these_lines);
      # For now, we just handle 1 thru 4 lines the same, and punt the rest
      if ($num_lines > 5) {
        die "Oops, I can't handle more than 5 lines of label yet.  Sorry!";
***************
*** 117,125 ****
        for (my $line = 0; $line < $num_lines; $line++)
        {
          my $this_line = ($upmost_line_start - ($line * $distance_down));
!         $this_code .= "$text_margin $this_line\n";
          $this_code .= "moveto\n";
!         $this_code .= "(" . $these_lines[$line] . ")\n";
          $this_code .= "show\n";
        }
        $this_code .= "stroke\n";
--- 122,130 ----
        for (my $line = 0; $line < $num_lines; $line++)
        {
          my $this_line = ($upmost_line_start - ($line * $distance_down));
!         $this_code .= "$text_margin $this_line ";
          $this_code .= "moveto\n";
!         $this_code .= "(" . $these_lines[$line] . ") ";
          $this_code .= "show\n";
        }
        $this_code .= "stroke\n";
***************
*** 181,186 ****
--- 186,192 ----
      $Vert_Num_Labels       = 10;
      $Font_Name             = "Times-Roman";
      $Font_Size             = 12;
+     $Number_Per_Page      = 30;
    }
    elsif (($ntype eq "avery5167") or ($ntype eq "macoll8100"))
    {
***************
*** 195,200 ****
--- 201,207 ----
      $Vert_Num_Labels       = 20;
      $Font_Name             = "Times-Roman";
      $Font_Size             = 7;
+     $Number_Per_Page       = 80
    }
    elsif (($ntype eq "avery5371") or ($ntype eq "macoll8550"))
    {
***************
*** 242,247 ****
--- 249,255 ----
    print "VertNumLabels   $Vert_Num_Labels\n";
    print "FontName        $Font_Name\n";
    print "FontSize        $Font_Size\n";
+   print "NumberPerPage   $Number_Per_Page\n";
  }
  
  
***************
*** 298,303 ****
--- 306,320 ----
      elsif (($key eq "outfile") && (! $Outfile)) {
        $Outfile = $val;
      }
+     elsif ($key eq "numberperpage")  {
+       $Number_Per_Page = &normalize_string ($val);
+     }
+     elsif ($key eq "labelcount") {
+       $Label_Count = &normalize_string ($val);
+     }
+     elsif ($key eq "pagesoflabels") {
+       $Pages_Of_Labels = &normalize_string($val);
+     }
      else {
        print "Unknown parameter line \"$_\"\n";
      }
***************
*** 794,809 ****
    print OUT "/labelclip {\n${clipper}\n} def\n";
  
    print OUT "\n";
  
!   print OUT "$Left_Margin\n";
!   print OUT "$Bottom_Margin\n";
    print OUT "translate\n";
!   print OUT "\n";
  
-   # Index into array of PostScript drawing chunks
-   my $code_idx = 0;
  
    # Outer loop is X coordinate, inner is Y
    for (my $x = 0; $x < $Horiz_Num_Labels; $x++)
    {
      my $this_x_step = ($x * ($Label_Width  + $Horiz_Space));
--- 811,833 ----
    print OUT "/labelclip {\n${clipper}\n} def\n";
  
    print OUT "\n";
+   # Index into array of PostScript drawing chunks
+   my $code_idx = 0;
  
!   for (my $z = 0; $z < $Pages_Of_Labels ; $z++) 
!   {
!   print OUT "%%Page: ".($z+1)." ".($z+1)."\n";
!   print OUT "%%BeginPageSetup\n";
!   print OUT "/pagelevel save def\n";
!   print OUT "$Left_Margin ";
!   print OUT "$Bottom_Margin ";
    print OUT "translate\n";
!   print OUT "%%EndPageSetup\n";
  
  
    # Outer loop is X coordinate, inner is Y
+ 
+ 
    for (my $x = 0; $x < $Horiz_Num_Labels; $x++)
    {
      my $this_x_step = ($x * ($Label_Width  + $Horiz_Space));
***************
*** 812,817 ****
--- 836,842 ----
      {
        my $this_y_step = ($y * ($Label_Height + $Vert_Space));
        my $this_code = $Label_Codes[$code_idx];
+ 
        
        print OUT "gsave\n";
        print OUT "$this_x_step $this_y_step\n";
***************
*** 822,832 ****
        print OUT "\n";
  
        $code_idx = ($code_idx + 1) % (scalar (@Label_Codes));
      }
    }
!   
    print OUT "showpage\n";
!   
    close (OUT);
  }
  
--- 847,858 ----
        print OUT "\n";
  
        $code_idx = ($code_idx + 1) % (scalar (@Label_Codes));
+       print "$code_idx\n";
      }
    }
!   print OUT "pagelevel restore\n";
    print OUT "showpage\n";
!   }  
    close (OUT);
  }
